# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' C++ ANOVA Statistics Iterator
#'
#' @description
#' Optimized C++ implementation for computing ANOVA statistics across multiple traits.
#' Replaces R loop in mean_performance() that calls design_stats() for each trait.
#' Processes all traits in a single pass using vectorized operations.
#'
#' @param data_mat Numeric matrix of trait observations (n_obs x n_traits)
#' @param gen_idx Integer vector of genotype indices (1-based converted to 0-based internally)
#' @param rep_idx Integer vector of replication indices (1-based converted to 0-based internally)
#' @param col_idx Integer vector of column indices for LSD (NULL for RCBD/SPD)
#' @param main_idx Integer vector of main plot indices for SPD (NULL for RCBD/LSD)
#' @param design_type Integer: 1=RCBD, 2=LSD, 3=SPD
#'
#' @return List containing matrices:
#'   - GMS: Genotype Mean Squares (1 x n_traits)
#'   - EMS: Error Mean Squares (1 x n_traits)
#'   - EMS_MAIN: Main plot error mean squares for SPD (1 x n_traits)
#'   - DFG: Degrees of freedom for genotypes (scalar)
#'   - DFE: Degrees of freedom for error (scalar)
#'   - DFE_MAIN: Degrees of freedom for main plot error in SPD (scalar)
#'   - n_rep: Number of replications (scalar)
#'   - n_gen: Number of genotypes (scalar)
#'   - n_main: Number of main plots for SPD (scalar)
#'
#' @details
#' Algorithm optimizations:
#' - Single pass through data for all traits (eliminates R loop overhead)
#' - Pre-computes all grouped sums for reuse across traits
#' - Vectorized operations using Eigen
#' - Returns statistics needed for F-tests, CV%, heritability, etc.
#'
#' @keywords internal
cpp_anova_iterator <- function(data_mat, gen_idx, rep_idx, col_idx = NULL, main_idx = NULL, design_type = 1L) {
    .Call(`_selection_index_cpp_anova_iterator`, data_mat, gen_idx, rep_idx, col_idx, main_idx, design_type)
}

#' C++ Iterator for Selection Index Combinations
#' 
#' Vectorized computation of selection indices for all trait combinations.
#' Replaces R loop with single-pass compiled code for massive speedup.
#' 
#' @param pmat Phenotypic variance-covariance matrix (n x n)
#' @param gmat Genotypic variance-covariance matrix (n x n)
#' @param wmat Weight vector (n x 1) or matrix (n x wcol)
#' @param comb_matrix Matrix of trait combinations (ncomb x ncomb_total)
#'   Each column is one combination (0-indexed trait indices)
#' @param wcol Weight column to use (0-indexed)
#' @param const_factor Constant factor (default: 2.063)
#' @param PRE_constant Constant for PRE calculation (default: 100 or 100/GAY)
#' 
#' @return List with:
#'   - IDs: Character vector of combination IDs
#'   - b_matrix: Matrix of b coefficients (ncomb_total x max_traits)
#'   - GAs: Numeric vector of genetic advances
#'   - PREs: Numeric vector of percent relative efficiencies
#' 
#' @keywords internal
cpp_comb_iterator <- function(pmat, gmat, wmat, comb_matrix, wcol = 0L, const_factor = 2.063, PRE_constant = 100.0) {
    .Call(`_selection_index_cpp_comb_iterator`, pmat, gmat, wmat, comb_matrix, wcol, const_factor, PRE_constant)
}

#' Generic C++ Math Primitives for Experimental Design Statistics
#' @name cpp_math_primitives
#'
#' @description
#' Generic mathematical operations optimized with C++/Eigen.
#' No design-specific logic - purely mathematical primitives that can be
#' orchestrated by R code to implement any experimental design.
#'
#' This architecture allows:
#' - Easy addition of new experimental designs (in R only)
#' - C++ speed for heavy computation
#' - Single source of truth (design_stats.R)
#' - Better maintainability and testability
NULL

#' Compute Grouped Sums for Matrix Columns
#'
#' @description
#' Efficiently computes grouped sums for all columns of a matrix.
#' Equivalent to rowsum() in R but optimized for multiple columns.
#'
#' @param data_mat Numeric matrix (n_obs x n_traits)
#' @param group_idx Integer vector of group indices (1-based, converted to 0-based internally)
#'
#' @return Matrix of grouped sums (n_groups x n_traits)
#'
#' @keywords internal
cpp_grouped_sums <- function(data_mat, group_idx) {
    .Call(`_selection_index_cpp_grouped_sums`, data_mat, group_idx)
}

#' Compute Multiple Grouped Sums at Once
#'
#' @description
#' Computes grouped sums for multiple grouping variables simultaneously.
#' More efficient than calling cpp_grouped_sums multiple times.
#'
#' @param data_mat Numeric matrix (n_obs x n_traits)
#' @param group_indices List of integer vectors, each representing a grouping variable
#'
#' @return List of matrices, one for each grouping variable
#'
#' @keywords internal
cpp_multi_grouped_sums <- function(data_mat, group_indices) {
    .Call(`_selection_index_cpp_multi_grouped_sums`, data_mat, group_indices)
}

#' Compute Sum of Products Between Grouped Sums
#'
#' @description
#' Efficiently computes sum of products for grouped sum vectors.
#' Equivalent to crossprod(sums1, sums2) in R.
#'
#' @param sums1 Matrix of grouped sums (n_groups x n_traits)
#' @param sums2 Matrix of grouped sums (n_groups x n_traits)
#' @param divisor Scalar to divide sums by (e.g., n_replications)
#'
#' @return Matrix of sum of products (n_traits x n_traits)
#'
#' @keywords internal
cpp_crossprod_divided <- function(sums1, sums2, divisor) {
    .Call(`_selection_index_cpp_crossprod_divided`, sums1, sums2, divisor)
}

#' Compute Total Sum of Products
#'
#' @description
#' Efficiently computes element-wise sum of products across traits.
#' Returns matrix with TSP for all trait pairs.
#'
#' @param data_mat Numeric matrix (n_obs x n_traits)
#'
#' @return Matrix of total sum of products (n_traits x n_traits)
#'
#' @keywords internal
cpp_total_sum_of_products <- function(data_mat) {
    .Call(`_selection_index_cpp_total_sum_of_products`, data_mat)
}

#' Compute Correction Factor Matrix
#'
#' @description
#' Computes correction factor for all trait pairs.
#' CF[i,j] = (sum_i * sum_j) / n_obs
#'
#' @param data_mat Numeric matrix (n_obs x n_traits)
#'
#' @return Matrix of correction factors (n_traits x n_traits)
#'
#' @keywords internal
cpp_correction_factor_matrix <- function(data_mat) {
    .Call(`_selection_index_cpp_correction_factor_matrix`, data_mat)
}

#' Compute Grand Means
#'
#' @description
#' Computes mean for each trait (column).
#'
#' @param data_mat Numeric matrix (n_obs x n_traits)
#'
#' @return Vector of grand means (n_traits)
#'
#' @keywords internal
cpp_grand_means <- function(data_mat) {
    .Call(`_selection_index_cpp_grand_means`, data_mat)
}

#' Compute Trait-wise Min/Max
#'
#' @description
#' Computes minimum and maximum for each trait.
#'
#' @param data_mat Numeric matrix (n_obs x n_traits)
#'
#' @return List with 'min' and 'max' vectors
#'
#' @keywords internal
cpp_trait_minmax <- function(data_mat) {
    .Call(`_selection_index_cpp_trait_minmax`, data_mat)
}

#' Compute Genotype Means Matrix
#'
#' @description
#' Efficiently computes means for each genotype across all traits.
#' Equivalent to rowsum(data, genotypes) / counts but optimized.
#'
#' @param data_mat Numeric matrix (n_obs x n_traits)
#' @param gen_idx Integer vector of genotype indices (1-based)
#'
#' @return Matrix of genotype means (n_genotypes x n_traits)
#'
#' @keywords internal
cpp_genotype_means <- function(data_mat, gen_idx) {
    .Call(`_selection_index_cpp_genotype_means`, data_mat, gen_idx)
}

#' C++ Variance-Covariance Matrix Iterator
#'
#' @description
#' Optimized C++ implementation for computing variance-covariance matrices.
#' Replaces nested R loops in gen_varcov() and phen_varcov() with vectorized
#' operations. Processes all trait pairs in a single call using Eigen for
#' efficient matrix operations.
#'
#' @param data_mat Numeric matrix of trait observations (n_obs x n_traits)
#' @param gen_idx Integer vector of genotype indices (1-based converted to 0-based internally)
#' @param rep_idx Integer vector of replication indices (1-based converted to 0-based internally)
#' @param col_idx Integer vector of column indices for LSD (NULL for RCBD/SPD)
#' @param main_idx Integer vector of main plot indices for SPD (NULL for RCBD/LSD)
#' @param design_type Integer: 1=RCBD, 2=LSD, 3=SPD
#' @param cov_type Integer: 1=genotypic, 2=phenotypic
#'
#' @return Symmetric variance-covariance matrix (n_traits x n_traits)
#'
#' @details
#' Algorithm optimizations:
#' - Single pass through data for all trait pairs (eliminates R loop overhead)
#' - Uses Eigen's efficient matrix operations (crossprod, grouped sums)
#' - Pre-allocates all result matrices (no memory reallocation)
#' - Computes only upper triangle, then mirrors to lower (symmetric matrix)
#'
#' RCBD: Cov_G = (GMP - EMP) / r, Cov_P = Cov_G + EMP
#' LSD:  Cov_G = (GMP - EMP) / t, Cov_P = Cov_G + EMP  
#' SPD:  Cov_G = (GMP - EMP) / (r*a), Cov_P = Cov_G + EMP
#'
#' @keywords internal
cpp_varcov_iterator <- function(data_mat, gen_idx, rep_idx, col_idx = NULL, main_idx = NULL, design_type = 1L, cov_type = 1L) {
    .Call(`_selection_index_cpp_varcov_iterator`, data_mat, gen_idx, rep_idx, col_idx, main_idx, design_type, cov_type)
}

